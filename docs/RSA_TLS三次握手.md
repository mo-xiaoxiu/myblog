---
title: "RSA_TCP三次握手"
date: 2021-09-21T15:01:51+08:00
draft: true
---

# TLS三次握手

RAS算法下的三次握手流程：

## TLS第一次握手

客户端向服务端“打招呼”，发出**`Client Hello`**。`Client Hello`包含的信息有：***客户端生成的随机数（Client Random）****、TLS版本号、支持的密码套件列表*

## TLS第二次握手

服务端收到客户端的“招呼”后，确认信息：*确认（服务端）支持的TLS版本号，选定的密码套件，同样生成一个**服务端随机数（Server Random）** 

确认完毕后，服务端向客户端发出**`Server Certificate`**。含有数字证书

随后，服务端发送**`Server Hello Done`**，表示此次“打招呼”结束，“能给的都已经给你”

### 数字证书

**`数字证书`**，是由**CA（Certificate Authority，证书认证机构）**签发的。相当于网络世界里的公安局，具有极高的可信度

包含了：

*持有者公钥、证书有效时间、持有者信息、证书认证机构CA的信息、CA对这份文件的数字签名*

#### 数字证书签发和确认流程：

* **服务端**：在服务端，将持有者信息，持有者公钥，证书有效时间等信息包装起来，用给定的Hash算法算出一个Hash值，CA再根据**CA的私钥**对此哈希值进行加密，得出数字签名放进数字证书
* **客户端**：在客户端，将收到的证书通过相同的Hash算法计算得出Hash值（H1），再将证书中的数字签名利用**CA的公钥**进行解密得到另一个Hash值（H2），对比H1、H2。相同则证书可信任

#### 实际应用中的数字证书确认

往往是多级嵌套的。比如客户端接收到baidu.com的证书：

1. 客户端收到百度的证书后，经过确认发现**无法用本地根证书中的公钥进行确认**，又得到证书中的**签发者信息**，所以向CA请求中间证书；
2. 请求到中间证书后，发现是由某签发机构签发的，**该签发证书没有上级签发机构了**，所以此请求的中间证书即使**根证书**（自签证书），客户端再**根据本地根证书清单中的信息对此请求的证书进行验证**，即用根证书中的公钥验证。验证通过则说明该自签证书可信任；
3. **由于该自签证书可信任，所以百度证书可信任**

用户信任操作系统，所以由软件商预载的根证书可信任

## TLS第三次握手

客户端收到服务端发出的数字证书后，对其进行上述所提到的确认，接着，客户端再生成一个随机数**`pre-master`**，用**RSA公钥加密**，通过**`Change Cipher Key Exchange`**消息传给服务端

服务端收到后，用**RSA私钥解密**，得到客户端的随机数`pre-master`



双方根据三个随机数**Client Random、Server Random、pre-master**，生成**会话密钥**，是一个**对称密钥**，后续对HTTP请求/响应都用此加密方式

随后**客户端发送`Change Cipher Spec`**，告诉服务器开始使用对称加密方式发送消息

**客户端再发送`Encrypted Handshake Message`**(Finish)消息，将之前所有发送的数据做一个**摘要**，再用**会话密钥加密**，让服务器做**验证**（验证加密通信是否可用以及之前的握手信息是否被中途篡改）

## TLS第四次握手

服务器也是同样的操作。**发送`Change Cipher Spec`和`Encrypted Handshake Message`消息，如果双方验证都没有问题，则握手正式结束**

---

此后，就用**会话密钥**加解密HTTP请求和响应了

# RSA算法的缺陷

## 问题

**使用RSA密钥协商算法最大的问题：不支持前向保密**

客户端传递随机数加密方式：利用公钥

服务端收到后：利用私钥解密

万一服务端的私钥泄漏，则之前所有的TLS通讯都会被破解

## 改进

**DH密钥协商算法**

---



