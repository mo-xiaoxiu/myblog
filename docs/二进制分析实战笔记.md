# 二进制分析实战笔记

## C编译过程

### 预处理阶段

* `gcc`选项
  * -E：告诉GCC在预处理后停止
  * -P：使GCC忽略调试信息

### 编译阶段

* 优化级别：-O0到-O3
* `gcc`选项
  * -S：告诉GCC编译阶段之后停止，并**将汇编文件存储到磁盘**（.s是汇编文件的常规拓展名）
  * -masm-intel：以intel语法而不是默认的AT&T语法翻译汇编语言

### 汇编阶段

汇编阶段的**输入是在编译阶段生成的汇编语言集，输出是一组对象文件**，有时称之为**模块**

对象文件原则上包含由处理器执行的**机器指令**

* `gcc`选项
  * -c：生成对象文件
* 最低有效位（LSB）：数字在内存中的排序是以最低有效字节优先的
* 可重定位文件：不依赖于放置内存的任何特定地址，可以随意移动
  * **需要对象文件可重定位的原因：对象文件相互独立编译，因此汇编程序在组装对象文件时无法知道其他对象文件的内存地址**
* `file`
  * 输出的第一部分显示文件符合二进制可执行文件的ELF规范
  * 64位ELF二进制文件
  * 最低有效位
  * **可重定位**

### 链接阶段

链接阶段有时会包含额外的优化过程，被称之为**链接时优化**

通常链接器和编译器相互独立，编译器通常实现前面所有的步骤

* 对象文件可以引用**其他对象文件**或者程序**外部库中的函数或者变量**。
  * 在链接阶段之前，引用代码和数据的地址还不清楚，因此**对象文件只包含重定位符号**
  * 这些符号指定最终**如何解析函数和变量引用**
* 在链接上下文中，**依赖于重定位符号的引用称之为符号引用**
  * 当一个**对象文件**通过**绝对地址引用自己的函数或变量的时候，该引用也会被符号化**
* 静态库：被合并到二进制可执行文件中，允许完全解析对静态库的任何引用，在系统上运行所有程序的内存中共享
* 动态库：仅将动态库加载到内存中一次，并且任何想要使用该库的二进制文件都需要使用此共享副本
  * 链接阶段，动态库将驻留的内存地址还不清楚，无法解析对其的引用
  * **在最终的可执行文件中，链接器也会对这些库文件留下符号引用，并且在将二进制文件实际加载到要执行的内存中之前，不会解析这些引用**

## 符号和剥离的二进制文件

### 查看符号信息

* `readelf`
  * 符号
    * main函数有一个：**指定了当二进制文件加载到内存时main将驻留的地址；输出还显示main的代码大小（32字节），并指出正在处理一个函数符号（类型为FUNC）**
* 链接器只需要基本符号
  * 为了调试，可以转译出更多信息：**调试符号提供了源代码行和二进制指令之间的完整映射关系，甚至描述了函数的参数、堆栈帧信息等**
    * 对于ELF二进制文件，调试符号通常以**DWARF格式**生成，DWARF信息通常嵌在二进制文件中

### 剥离二进制文件

* `strip`
  * 只剩下少量符号

## 反汇编二进制文件

### 查看对象文件

* `objdump`

```shell
ogjdump -sj .rodata test.o

objdump -M intel -d test.o # intel语法反汇编对象文件所有代码
```

`.rodata`：只读数据；.rodata节内容由ASCII编码字符串组成，可以看到相同字节的人类可读表示

```shell
readelf --relocs test.o
```

* 每行最左列是对象文件在解析引用时必须填充的偏移量
  * 等于需要固定指令的偏移量加1
    * **原因：只想覆盖指令的操作数，而非指令的操作码**
    * 对于两个需要固定的指令，操作码均为一个字节，因此指向该指令的操作数，重定位符号需要跳过操作码的字节长度

