# 有限状态机

逻辑单元内部的编程方式

**状态独立的有限状态机**

```cpp title="状态独立的有限状态机"
STATE_MACHINE(Package _pack) {
    PackageType _type = _pack.getType();
    switch(_type) {
        case type_A:
            process_package_A(_pack);
            break;
        case type_B:
            process_package_B(_pack);
            break;
    }
}
```

**带状态转移的有限状态机**

```cpp title="带状态转移的有限状态机"
STATE_MACHINE() {
    State cur_state = type_A; //先定义一开始的状态
    while(cur_state != type_C) {
    	Package _pack = getNewPackage(); // 获得新的数据包
    	switch(cur_state) {
        	case type_A:
            	process_package_A(_pack);
            	cur_state = type_B; // 状态转移
                break;
        	case type_B:
            	process_package_B(_pack);
            	cur_state = type_C; // 状态转移
                break;
        }        
    }
} //type_A: 状态机的开始状态；type_C：状态机的结束状态
```



## http请求的读取与分析

* http头部结束：一对回车换行符
* 第一次读操作没有读入整个http头部，即没有遇到空行（一对回车换行符）：等待客户继续写数据再次读入
* 每完成一次读操作，分析数据中是否有空行
* 寻找空行的同时，完成对http头部的分析

```cpp title="http头部读取与分析"
#include<sys/socket.h>
#include<netinet/in.h>
#include<arpa/inet.h>
#include<assert.h>
#include<stdio.h>
#include<unistd.h>
#include<errno.h>
#include<string.h>
#include<fcntl.h>

#define BUFFER_SIZE 4096 //读缓冲区大小
//主状态机状态
enum CHECK_STATE {
    CHECK_STATE_REQUESTLINE = 0, //当前正在分析请求行
    CHECK_STATE_HEADER //当前正在分析头部信息
};

//从状态机的状态
enum LINE_STAET {
    LINE_OK = 0, //完整行
    LINE_BAD, //行出错
    LINE_OPEN //行数据尚不完整
};

//服务器http的请求结果
enum HTTP_CODE {
    NO_REQUEST, //请求不完整，继续读客户数据
    GET_REQUEST, //获得一个完整的请求
    BAD_REQUEST, //客户请求有错误
    FORBIDDEN_REQUEST, //客户对资源没有访问权限
    INTERNAL_ERROR, //服务器内部错误
    CLOSED_CONNECTION //客户已关闭连接
}；

    
//接收正确与错误的信息
static const char* szert[] = {"I get a correct result\n", 
                             "Something wrong\n"};



//从状态机：解析一行内容
LINE_STATE parse_line(char* buffer, int& checked_index, int& read_index) {
    char tmp;
    // checked_index 指向buffer 中当前正在分析的字节
    // read_index 指向buffer数据尾部的下一字节
    // 0~checked_index 字节已经分析完
    // checked_index ~ (read_index-1) 字节下个循环分析
    for(; checked_index < read_index; ++checked_index) {
        //获得当前要分析的字节
        tmp = buffer[checked_index];
        //若当前字符是“\r”，可能读到完整的一个行，继续分析
        if(tmp = '\r') {
            //恰巧是读缓冲区中最后一个读入的数据，不是完整的一行
            if(checked_index + 1 == read_index) return LINE_OPEN;
            //如果下一个字符是“\n”，说明是完整的一行
            else if(buffer[checked_index + 1] == '\n')	{
                buffer[checked_index++] = '\0';
                buffer[checked_index++] = '\0';
                return LINE_OK;
            }
            
            //否则当成出错
            return LINE_BAD;
        }
        
        //如果读到“\n”，可能读到完整的一行，继续分析
        else if(tmp == '\n') {
            //上一个字节是“\r”，则说明读到完整的一行
            if((checked_index > 1) && buffer[checked - 1] == '\r') {
                buffer[checked - 1] = '\0';
                buffer[checked++] = '0';
                return LINE_OK;
            }
            
            return LINE_BAD;
        }
    }
    
    // 所有内容分析完，没有“\r”
    return LINE_OPEN;
}

//分析请求行

```