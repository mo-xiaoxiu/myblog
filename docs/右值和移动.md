# 右值和移动

## 值类别

* `lvalue`：左值
  * 变量、函数、数据成员；
  * 返回左值引用的表达式：`++x`、`x = 1`、`cout<<" "`
  * 字符串字面量：`"helloworld"`
* `rvalue`：右值
* `glvalue`：广义左值
* `xvalue`：将亡值
* `prvalue`：纯右值
  * 返回非引用类型的表达式：`x++`、`x + 1`、`make_shared<int>(5)`
  * 除了字符串字面量之外的字面量：42、`true`

### 知识点

* 右值可以绑定到常量左值引用上`const T&`，不可以绑定到非常量左值引用

* 右值引用`T&&`可以使用`const`或者`volatile`来修饰

* **类型是右值引用的变量是左值** 

* `std::move(ptr1)`等价于`static_cast<smart_ptr<shared>&&>(ptr1)`，结果是指向ptr1的右值引用；`std::move()`转化后的右值是一个将亡值，即`xvalue`

* 如图所示：

  ![左值与右值](https://cdn.jsdelivr.net/gh/mo-xiaoxiu/imagefrommyblog@main/data/%E5%B7%A6%E5%80%BC%E4%B8%8E%E5%8F%B3%E5%80%BC.png)

## 生命周期和表达式类型

* 一个临时对象会在包含这个临时变量的完整表达式估值完成后，按照生成顺序的的逆序被销毁，*除非有生命周期的延长发生*

```cpp title=“生命周期.cpp”
#include <iostream>
#include <stdio.h>


class Shape
{
public:
    virtual ~Shape(){}
};

class Circle:public Shape
{
public:
    Circle(){std::cout<<"Circle constructor."<<std::endl;}
    ~Circle(){std::cout<<"Circle destructor."<<std::endl;}
};

class Triangle:public Shape
{
public:
    Triangle(){std::cout<<"Triangle constructor."<<std::endl;}
    ~Triangle(){std::cout<<"Triangle destructor."<<std::endl;}
};

class result
{
public:
    result(){std::cout<<"result constructor."<<std::endl;}
    ~result(){std::cout<<"result destructor."<<std::endl;}
};

result process(const Shape& shape_1, const Shape& shape_2) {
    std::cout<<"process called."<<std::endl;
    return result();
}

int main(){
    std::cout<<"main called."<<std::endl;
    process(Circle(), Triangle());
    return 0;
}

```

*测试环境：Ubuntu-18.04.6；编译器：VScode；输出结果如下：*

```
main called.
Triangle constructor.
Circle constructor.
process called.
result constructor.
result destructor.
Circle destructor.
Triangle destructor.
```

* **如果一个`prvalue`被绑定到一个引用上，则它的生命周期将和这个引用一样长**

  将上述代码中更改如下：

  ```cpp
  result&& r = process(Circle(), Triangle());
  ```

  *输出结果如下：*

  ```
  main called.
  Triangle constructor.
  Circle constructor.
  process called.
  result constructor.
  Circle destructor.
  Triangle destructor.
  result destructor.
  ```

  