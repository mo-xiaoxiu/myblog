# 网络编程知识点随记

## 信号

* 信号函数：

  * signal：

    ```cpp
    #include <signal.h>
    
    _sighandler_t signal(int sig, _sighandler_t _handler);
    ```

    返回值是前一次调用signal函数时传入的函数指针（第一次调用是信号sig对应的默认处理函数指针SIG——DEF）

  * sigaction：

    ```cpp
    #include <signal.h>
    
    int sigaction(int sig, const struct sigaction* act, struct sigaction* oact);
    ```

    act：指定新的信号处理方式；oact：输出之前的信号处理方式；

    *sigaction*结构体：

    ```c
    struct sigaction
    {
    #ifdef USE POSIX199309
    	union
    	{
    	_sighandler_t sa_handler;	//sa_handler 成员指定倌号处理函数
    	void (*sa_sigaction) ( int , siginfo_t • , void• ) ;
    	}
        _sigaction_handler;
    # define sa_handler __sigaction_handler.sa_handler
    # define sa_sigaction __sigaction_handler.sa_sigaction
    #else
    	_sighandler_t sa_handler;
    #endif
        //sa_mask 成员设置进程的信号掩码（确切地说是在进程原有信号掩码的基础上增加信号掩码），
        //以指定哪些信号不能发送给本进程
    	_sigset_ t sa_mask;	
    	int sa_flags;
    	void (* sa_restorer) (void) ;
    };
    ```

    

* SIGCHLD信号：子进程结束运行，其父进程会收到SIGCHLD信号。该信号的默认处理动作是忽略。可以捕捉该信号，在捕捉函数中完成子进程状态的回收

  ```cpp title="SIGCHLD.c"
  //当options 的取值是WNOHANG 时， waitpid 调用将是非阻塞的：如果pid 指定的目标子进程还没有结束或意外终止， 则waitpid 立即返回0: 如果目标子进程确实正常退出了，则waitpid 返回该子进程的PID 
  
  static void handle_child(int sig){
      pid_t pid;
      int stat;
      while(pid = waitpid(-1, &stat, WNOHANG) > 0) {
          /*对结束的子进程进行善后处理*/
      }
  }	
  ```







## socket

* accept2返回EMFILE的处理：

  * 调高进程文件描述符的数量

  * 死等

  * 退出程序

  * 关闭监听套接字

  * 如果是epoll模型，可以改用ET模式。问题：漏掉一次accept2，程序再也不会收到新的连接

  * **准备一个空闲的文件描述符。遇到这种情况，先关闭这个空闲的文件描述符，此时获得一个文件描述符名额，再次accept（2）就可以拿到这个socket连接的文件描述符，此时再关闭close文件描述符，就可以做到优雅关闭；最后重新打开这个文件描述符，以备下次再次出现这种情况使用**

    ```cpp
    if (connfd == -1)
    {
        if (errno == EMFILE)
        {
            close(idlefd);
            idlefd = accept(listenfd, NULL, NULL);
            close(idlefd);
            idlefd = open("/dev/null", O_RDONLY | O_CLOEXEC);
            continue;
        }
        else
            ERR_EXIT("accept4");
    }
    ```





## 基于对象和面向对象

* C编程风格：注册全局函数到网络库，网络库通过函数指针回调

* 面向对象风格：用一个具体类继承一个抽象类，实现接口（函数）

* 基于对象风格：用一个类包含一个**具体类对象**，在构造函数中使用`boost::bind`来注册成员函数

  * `boost::function`：

    ```cpp
    #include <iostream>
    #include <boost/function.hpp>
    #include <boost/bind.hpp>
    using namespace std;
    
    class Foo
    {
    public:
        void memberFunc(double d, int i, int j) {
            cout<<d<<endl;
            cout<<i<<endl;
            cout<<j<<endl;
        }
    };
    
    int main () {
        Foo foo;
        
        boost::function<void(int)> fp = boost::bind(&Foo::memberFunc, &foo, 0.5, _1, 10); //_1是占位参数；&foo相当于传入this指针
        
        return 0;
    }
    ```





