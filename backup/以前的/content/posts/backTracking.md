---
title: "回溯算法"
date: 2021-11-12T14:09:58+08:00
draft: true
---

# 回溯

可以将问题的暴力解法抽象成一颗 N 叉树，递归遍历所有可能的方法

回溯，顾名思义，必定有回的步骤，这就相当于在树的某个节点以某个孩子节点为路径递归遍历下去，当触及到该路径的叶子节点时，一层一层回到当前节点的过程

## 电话号码的字母组合

*原题链接：https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/*

```
给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。答案可以按 任意顺序 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。



 

示例 1：

输入：digits = "23"
输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
示例 2：

输入：digits = ""
输出：[]
示例 3：

输入：digits = "2"
输出：["a","b","c"]
 

提示：

0 <= digits.length <= 4
digits[i] 是范围 ['2', '9'] 的一个数字。


```

### 回溯算法过程

#### 递归函数的参数和返回值

* 参数：目标值
* 返回值：由于回溯需要遍历一整棵树所以不需要返回值，只需要设置存放结果的全局变量即可

#### 递归终止条件

当字母组合元素个数到达“按键”字符串组合的数量时，满足条件，将组合放入结果并返回

#### 单层递归逻辑

* 先将每个按键数字对应的几个字母的字符串用数组映射出来
* 将按键数字转化为对应的字母字符串，对于同一树枝，每次遍历都从字母字符串的第一个字母开始，这就要求递归遍历的时候，索取按键字符串中的数字位置要不断+1；对于同一树层，每次遍历去下一个数字
* 回溯：将字母放入临时字符串中，在下一次递归时判断是否满足条件；回到当前节点时，将该字母取出，放入下一个按键字母

### 完整代码实现：

```C++
class Solution {
private:
    // 将电话号码连键化成数组（数组下标即为按键号码）
    const string letterMap[10]={
        "", // 0
        "", // 1
        "abc", // 2
        "def", // 3
        "ghi", // 4
        "jkl", // 6
        "mno", // 7
        "pqrs", // 8
        "tuv", // 9
        "wxyz", // 9
    };

    vector<string>res;  // 创建全局变量数组存放所有结果
    string s;           // 创建全局变量字符串存放遍历到的字符，作为一组组合

public:
    // 回溯函数：
    // 传入参数：目标值（所输入的数字），遍历深度
    void backtracking(const string& digits,int index){
        // 终止条件： 当遍历深度与所要求的（输入数字）长度相同时，得到一组结果，放入结果数组中，并返回
        if(index==digits.size()){
            res.push_back(s);
            return;
        }

        // 将输入数字组合的每个字符转换成对应的数字
        int dig=digits[index]-'0';
        // 输入数字对应的按键，将其字符串放入临时变量中
        string letters=letterMap[dig];
        // 单层逻辑： 横向遍历放入临时对象的字符串，进行组合
        for(int i=0;i<letters.size();i++){
            // 先将临时对象中第一个字符放入组合中，开始回溯所有可能
            s.push_back(letters[i]);
            backtracking(digits,index+1);
            s.pop_back();
        }
    }

    vector<string> letterCombinations(string digits) {
        if(digits.size()==0) return res;

        backtracking(digits,0);

        return res;
    }
};
```

---

## 组合总和 III

*原题链接：https://leetcode-cn.com/problems/combination-sum-iii/*

```
找出所有相加之和为 n 的 k 个数的组合。组合中只允许含有 1 - 9 的正整数，并且每种组合中不存在重复的数字。

说明：

所有数字都是正整数。
解集不能包含重复的组合。 
示例 1:

输入: k = 3, n = 7
输出: [[1,2,4]]
示例 2:

输入: k = 3, n = 9
输出: [[1,2,6], [1,3,5], [2,3,4]]

```

**思路：**

求组和问题一般使用的是回溯算法

可以将求组和的整个过程抽象成遍历一颗N叉树的取值结果

* N叉树：

  为什么抽象成一颗N叉树呢？因为求组和的问题如果抽象成N叉树就可以权举所有可能了

  * N叉树节点：待组合的元素

回溯必然就需要先递归才可以做到

递归在这里是如何完成的？

#### 递归函数参数和返回值

* 首先需要确定徐不需要返回值：由于递归遍历的是一整棵树，而且不需要类似重构这样的需要知道上一个节点等挂载操作，所以不需要返回值

  那遍历的元素如何加入组合呢？又如何将组合记录下来？我们可以设置两个全局变量：一个用于遍历过程的存放元素构成组合数组，一个用于将所有满足结果的组合存储起来的结果数组

* 那递归函数的参数？

  在递归的过程中，我们知道N叉树的节点为待组合的元素，那就需要一个值去记录每一层遍历的待组合元素到了那个位置，题目要求用于组合的数是从`1~9`，所以我们可以使用数组下标的方式来记录遍历到了那个数，比如一开始遍历位置为 1 ，遍历的数就是1

  之后需要计算总和，所以需要在每一层遍历的过程中去记录当前的总和

#### 递归终止条件

遍历到哪里才算是结束呢？

很显然，这里当组合存放元素的个数满足题目给定的条件参数时，将其视为一个满足条件的组合

#### 单层递归逻辑

需要遍历数字`1~9`，计算总和，记录当前遍历到了那个数字，传给下一层遍历作为遍历位置

之后回溯，将各种增进的条件回复到上一步，当作什么也没发生，继续下一个数的尝试......

### 代码实现

```C++
class Solution {
public:
    // 存放结果的数组
    vector< vector<int> >res;
    // 存放组合元素
    vector<int> path;

    // 回溯函数
    void backTracking(int k,int n,int sum,int startIndex) {
        // 修枝剪叶
        if(sum > n) return;
        // 递归终止条件：遍历深度
        if(k == path.size()) {
            if(sum == n) {
                res.push_back(path);
                return;
            }
        }
        // 单层递归逻辑：含修枝剪叶
        for(int i=startIndex; i<=9-(k-path.size())+1; i++) {
            sum += i;
            path.push_back(i);
            backTracking(k,n,sum,i+1);
            path.pop_back();
            sum -= i;
        }
    }

    vector<vector<int>> combinationSum3(int k, int n) {
        backTracking(k,n,0,1);
        return res;
    }
};
```



---

