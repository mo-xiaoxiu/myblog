---
title: "背包初始"
date: 2021-10-20T14:11:57+08:00
draft: true
---

# 背包

背包问题是**动态规划**的经典问题

## 0-1背包问题

| 物品 | 价值 |
| :--: | :--: |
|  0   |  0   |
|  1   |  15  |
|  3   |  30  |
|  4   |  40  |

**物品只能选择一次**，放入背包

## 动态规划五部曲

### 确定dp数组

这里可以使用dp二维数组来解决

* `dp[i][j]`：**物品 `0~i`放入背包时的重量`j`**，表示的是**背包的价值**

### 确定递推公式

* `dp[i][j]`是由什么决定的：上一次物品的存放程度决定的

  * 这次存放，不放物品 i ，背包的价值为：`dp[i-1][j]`

  * 这次存放，放入物品 i ，**背包的价值为=上一次存放的背包物品 + 除去本次存放的种类（放入物品 i 之后的背包容量）+ 物品 i 的价值**

    `dp[i-1][j-weight[i]] + value[i]`

* 求的是背包的最大价值，所以递推公式应该是：存放物品 i 和不存放物品 i 背包价值的最大值

```
dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]+value[i]])
```

### 初始化dp数组

具体地来看，

```
      \  价值     15      30       40 
  物品  \ ——————————————————————————————  
   0    |         0       0        0
   1    |         15
   3    |         15
   4    |         15
```

由二维数组的特征来看，dp数组的元素值是由上一行和左上方的值推导而来，所以只需要初始化第一行和第一列的数组元素就可以了

* 第一行：物品0，说明没有物品，所以背包价值都为0
* 第一列：物品不管有多少，价值都只有15，所以背包的价值除了第一行之外，都为0
* 其余行列元素：初始为任意值都可以（为上一行和左上方推导而来，所以无所谓）

### 遍历顺序的确定

背包问题由两层for循环搞定背包和物品之间的遍历

* 先遍历背包，再遍历物品？

  体现在二维数组上就是**先行后列**，在for循环上就是：**外层循环遍历背包，内层循环遍历物品**。

  由于数组元素是由上一行和左上方的数值决定的，所以是可以的

* 先遍历物品，再遍历背包？

  体现在二维数组上就是**先行后列**，在for循环上就是：**外层循环遍历物品，内层循环遍历背包**

  理由同上

* 这里的“背包”是背包的容量

* **倒序遍历：**大可不必，理由同上

### 举例

这里可以通过完善上述表格来检验一下

## 代码实现

```C++
// 0-1背包问题母代码(二维)
void bags()
{
    vector<int> weight = {1, 3, 4};   //各个物品的重量
    vector<int> value = {15, 20, 30}; //对应的价值
    int bagWeight = 4;                //背包最大能放下多少重的物品

    // 二维数组：状态定义:dp[i][j]表示从0-i个物品中选择不超过j重量的物品的最大价值
    vector<vector<int>> dp(weight.size() + 1, vector<int>(bagWeight + 1, 0));	// 多出来初始化的行和列，所以 +1

    // 初始化:第一列都是0，第一行表示只选取0号物品最大价值
    for (int j = bagWeight; j >= weight[0]; j--)
        dp[0][j] = dp[0][j - weight[0]] + value[0];

    // weight数组的大小 就是物品个数
    for (int i = 1; i < weight.size(); i++) // 遍历物品(第0个物品已经初始化)
    {
        for (int j = 0; j <= bagWeight; j++) // 遍历背包容量
        {
            if (j < weight[i])           //背包容量已经不足以拿第i个物品了
                dp[i][j] = dp[i - 1][j]; //最大价值就是拿第i-1个物品的最大价值
            //背包容量足够拿第i个物品,可拿可不拿：拿了最大价值是前i-1个物品扣除第i个物品的 重量的最大价值加上i个物品的价值
            //不拿就是前i-1个物品的最大价值,两者进行比较取较大的
            else
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
        }
    }
    cout << dp[weight.size() - 1][bagWeight] << endl;
}

```

**优化：**

* dp数组优化：使用滚动的一维数组来进行替换。`dp[j]`：**表示的是背包容量为 j 时背包的最大价值**
* **递推公式：`dp[j]=max(dp[j],dp[j-weight[i]]+value[i])`**
* **遍历顺序：只能先遍历物品，再遍历背包容量**
  * **倒序遍历？**：**必须倒序遍历。**如果不倒序遍历的话，顺序遍历会使后序数组元素计算物品价值时重复计算多次（多次累加），因为dp数组中的元素是由它前一个元素决定的

*代码实现：*

```C++
void test_1_wei_bag_problem()
{
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    int bagWeight = 4;

    // 初始化
    vector<int> dp(bagWeight + 1, 0);
    for (int i = 0; i < weight.size(); i++)
    { // 遍历物品
        for (int j = bagWeight; j >= weight[i]; j--)
        {                                                     // 遍历背包容量(一定要逆序)
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); //不取或者取第i个
        }
    }
    cout << dp[bagWeight] << endl;
}

```

---

# 动态规划：最长公共子序列

## 动态规划四部曲

#### 确定dp数组

* `dp[i][j]`：表示在字符串1的前i个字符与字符串2的前j个字符的最长公共子序列

#### 确定递推公式

* 字符串1的第i个字符与字符串2的第j个字符相同：`dp[i][j]=dp[i-1][j-1]`，表示字符串前i-1个字符和字符串2前j-1个字符的最长公共子序列加一（加上当前情况）
* 字符串1的第i个字符与字符串2的第j个字符不相同：`dp[i][j]=max(dp[i-1][j],dp[i][j-1])`，表示字符串1的前i-1个字符与字符串2的前j个字符的最长公共子序列，和字符串的前i个字符与字符串2的前j-1个字符的最长公共子序列，取最大值（如果不相同，分别比较一个字符串的前一个位置与另一个字符串的当前位置）

#### 初始化

* `dp[0][j]`：当i=0时，表示字符串1为空，则字符串2不管是什么长度，都没有字符串与其匹配，所以`dp[0][j]=0`
* `dp[i][0]`：同上

#### 遍历顺序的确定

* 先遍历字符串1和先遍历字符串2是一样的：内外层for循环顺序
* 从小到大遍历即可，因为dp数组的每个位置的元素都是从上方、左方或者左上方求得的


```C++
class Solution{
public:
  int longestCommonSubsequence(string text1,string text2){
    int m=text1.size(); int n=text2.size();
    vector<vector<int>> dp(m+1,vector<int>(n+1));
    
    for(int i=1;i<=m;i++){
      char c1=text1[i-1];
      for(int j=1;j<=n;j++){
        char c2=text2[j-1];
        
        if(c1==c2){
          dp[i][j]=dp[i-1][j-1]+1;
        }else{
          dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
        }
      }
    }
    
    return dp[m][n];
  }  
};
```

---

# 动态规划：多边形三角形剖分的最低分数

*原题链接：https://leetcode-cn.com/problems/minimum-score-triangulation-of-polygon/submissions/*

```
给定 N，想象一个凸 N 边多边形，其顶点按顺时针顺序依次标记为 A[0], A[i], ..., A[N-1]。

假设您将多边形剖分为 N-2 个三角形。对于每个三角形，该三角形的值是顶点标记的乘积，三角剖分的分数是进行三角剖分后所有 N-2 个三角形的值之和。

返回多边形进行三角剖分后可以得到的最低分。
 

示例 1：

输入：[1,2,3]
输出：6
解释：多边形已经三角化，唯一三角形的分数为 6。
示例 2：



输入：[3,7,4,5]
输出：144
解释：有两种三角剖分，可能得分分别为：3*7*5 + 4*5*7 = 245，或 3*4*5 + 3*4*7 = 144。最低分数为 144。
示例 3：

输入：[1,3,1,4,1,5]
输出：13
解释：最低分数三角剖分的得分情况为 1*1*3 + 1*1*4 + 1*1*5 + 1*1*1 = 13。
 

提示：

3 <= A.length <= 50
1 <= A[i] <= 100

```



## 动态规划

由数组围成的多边形，假设其有N个顶点，先从中取出3个顶点（三个顶点组成三角形），之后再从剩下的顶点N-3个顶点中取出一个顶点组成四边形，划分三角形，之后再从剩下的顶点中取出一个顶点与之前的四边形组成五边形...... 以此类推

- 划分成三角形，可以直接计算出三角形值
- 划分成四边形，需要再次划分为两个三角形
- 划分成五边形，需要划分为一个四边形和一个三角形
- 。。。

### 确定dp数组

- `dp[i][j]`：表示在由数组组成的多边形中，区间【i，j】内剖分的三角形值的总和
- i：从N-3开始
- j：从2开始

### 确定递推公式

- `dp[i][j = value[i] * value[j] * value[m] + dp[i][m] + dp[m][j]]
- m：表示的是在区间【i，j】之间划分三角形`

### 初始化dp数组

由于是求分数的最低值，所以先将dp数组的各个元素初始化为0

- 如果`dp[i][j] = 0`，说明此时只是组成一个三角形，所以先初始化那些划分的单独的三角形为：
  `dp[i][j] = value[i] * value[j] * value[m] + dp[i][m] + dp[m][j]`
- 之后需要遍历每个区间，将其划分为三角形和多边形，进行递归

### 遍历顺序

首先需要两层for循环，确定 i，j 区间：外两层循环不需要顺序
再者，需要一层内循环用于划分三角形
**先确定区间，再划分三角形**

```C++
class Solution {
public:
    int minScoreTriangulation(vector<int>& values) {
        int n=values.size();

        int dp[n][n];   // 确定dp数组
        memset(dp,0,sizeof(dp));    // 初始化

        for(int i=n-3;i>=0;i--){    // 确定区间
            for(int j=2;j<n;j++){
                // 划分三角形
                for(int m=i+1;m<j;m++){
                    // 先初始化单独的三角形
                    if(dp[i][j]==0){
                        dp[i][j]=values[i]*values[j]*values[m]+dp[i][m]+dp[m][j];
                        // 划分多边形：多边形和三角形
                    }else{
                        dp[i][j]=min(dp[i][j],dp[i][m]+dp[m][j]+values[i]*values[j]*values[m]);
                    }
                }
            }
        }

        // 返回最大区间（整个多边形）的三角形值
        return dp[0][n-1];
    }
};
```

---



# 动态规划：猜数字大小 II

*原题链接：https://leetcode-cn.com/problems/guess-number-higher-or-lower-ii/submissions/*

```
我们正在玩一个猜数游戏，游戏规则如下：

我从 1 到 n 之间选择一个数字。
你来猜我选了哪个数字。
如果你猜到正确的数字，就会 赢得游戏 。
如果你猜错了，那么我会告诉你，我选的数字比你的 更大或者更小 ，并且你需要继续猜数。
每当你猜了数字 x 并且猜错了的时候，你需要支付金额为 x 的现金。如果你花光了钱，就会 输掉游戏 。
给你一个特定的数字 n ，返回能够 确保你获胜 的最小现金数，不管我选择那个数字 。

 

示例 1：


输入：n = 10
输出：16
解释：制胜策略如下：
- 数字范围是 [1,10] 。你先猜测数字为 7 。
    - 如果这是我选中的数字，你的总费用为 $0 。否则，你需要支付 $7 。
    - 如果我的数字更大，则下一步需要猜测的数字范围是 [8,10] 。你可以猜测数字为 9 。
        - 如果这是我选中的数字，你的总费用为 $7 。否则，你需要支付 $9 。
        - 如果我的数字更大，那么这个数字一定是 10 。你猜测数字为 10 并赢得游戏，总费用为 $7 + $9 = $16 。
        - 如果我的数字更小，那么这个数字一定是 8 。你猜测数字为 8 并赢得游戏，总费用为 $7 + $9 = $16 。
    - 如果我的数字更小，则下一步需要猜测的数字范围是 [1,6] 。你可以猜测数字为 3 。
        - 如果这是我选中的数字，你的总费用为 $7 。否则，你需要支付 $3 。
        - 如果我的数字更大，则下一步需要猜测的数字范围是 [4,6] 。你可以猜测数字为 5 。
            - 如果这是我选中的数字，你的总费用为 $7 + $3 = $10 。否则，你需要支付 $5 。
            - 如果我的数字更大，那么这个数字一定是 6 。你猜测数字为 6 并赢得游戏，总费用为 $7 + $3 + $5 = $15 。
            - 如果我的数字更小，那么这个数字一定是 4 。你猜测数字为 4 并赢得游戏，总费用为 $7 + $3 + $5 = $15 。
        - 如果我的数字更小，则下一步需要猜测的数字范围是 [1,2] 。你可以猜测数字为 1 。
            - 如果这是我选中的数字，你的总费用为 $7 + $3 = $10 。否则，你需要支付 $1 。
            - 如果我的数字更大，那么这个数字一定是 2 。你猜测数字为 2 并赢得游戏，总费用为 $7 + $3 + $1 = $11 。
在最糟糕的情况下，你需要支付 $16 。因此，你只需要 $16 就可以确保自己赢得游戏。
示例 2：

输入：n = 1
输出：0
解释：只有一个可能的数字，所以你可以直接猜 1 并赢得游戏，无需支付任何费用。
示例 3：

输入：n = 2
输出：1
解释：有两个可能的数字 1 和 2 。
- 你可以先猜 1 。
    - 如果这是我选中的数字，你的总费用为 $0 。否则，你需要支付 $1 。
    - 如果我的数字更大，那么这个数字一定是 2 。你猜测数字为 2 并赢得游戏，总费用为 $1 。
最糟糕的情况下，你需要支付 $1 。
 

提示：

1 <= n <= 200

```

## 确定dp数组

* `dp[i][j]`：表示在区间`[i,j]`之间猜数字的最小成本

## 确定递推公式

对于猜数字，假设猜的数字为 k ，有几种情况：

1. 正好猜中，费用为：0
2. 没猜中，费用为：k；然后根据提示选择区间`[i,k-1]`或者是`[k+1,j]`再猜数字。所以可以写为：`max(dp[i][k-1], dp[k+1][j])`

设本次猜数字的费用为`res`，则上述总结为：**`dp[i][j] = min(res, k + max(dp[i][k-1],dp[k+1][j]))`**

## 初始化递推公式

* `dp[i][i]`：表示的是区间`[i,i]`猜数字的最小成本，那结果只可能是猜中 i 本身，费用为 0
* `dp[0][0]`：0
* `dp[i][0]`：区间左端点必须小于右端点，所以舍弃这个范围的数据
* `dp[0][j]`：由递推公式求出，不初始化

## 遍历顺序

首先得知道`dp[i][j]`是怎么得来的

要想知道`dp[i][j]`，由递推公式得，需要知道`dp[i][k-1]`和`dp[k+1][j]`，k是区间`[i,j]`之间的数字，可以得到`dp[i][j]`在几何关系上是从二维数组得左下角方向推出的，所以遍历循环应该体现为**从左下角往右上方**的方向

对于遍历的顺序讨论从二维数组的角度来说，就转化为先遍历行，还是列，才能体现上述遍历方向？

其实都可以，只要能体现遍历方向就可以

一般是先遍历行，再遍历列：这里遍历**行要从大到小，列要从小到大**

所以写代码时体现为：外层循环为行遍历，内层循环为列遍历

## 代码实现

```C++
class Solution{
public:
    int getMoneyAmount(int n) {
        // 创建一个二维数组 dp : dp[i][j]表示在区间[i,j]之间猜数字的最小成本
        vector< vector<int>> dp(n+1, vector<int>(n+1,0) );// 顺便完成初始化工作
        
        // 外层循环从二维数组的右上方数据（有效的数据，左下角数据无效）的最底下开始：行
        for(int i=n-1;i>=0;i--) {
            // 内层循环：列 从小到大
            for(int j=i+1;j<=n;j++) {
                int minCos = INT_MAX;// 记忆化搜索：临时变量记录费用
                // 猜数字
                for(int k=i;k<j;k++) {
                    minCos = min(minCos, k+max(dp[i][k-1], dp[k+1][j]));
                }
                dp[i][j] = minCos; 
            }
        }
        return dp[1][n];// 返回最大区间的费用
    }
};
```

---

