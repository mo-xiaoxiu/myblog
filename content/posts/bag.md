---
title: "背包初始"
date: 2021-10-20T14:11:57+08:00
draft: true
---

# 背包

背包问题是**动态规划**的经典问题

## 0-1背包问题

| 物品 | 价值 |
| :--: | :--: |
|  0   |  0   |
|  1   |  15  |
|  3   |  30  |
|  4   |  40  |

**物品只能选择一次**，放入背包

## 动态规划五部曲

### 确定dp数组

这里可以使用dp二维数组来解决

* `dp[i][j]`：**物品 `0~i`放入背包时的重量`j`**，表示的是**背包的价值**

### 确定递推公式

* `dp[i][j]`是由什么决定的：上一次物品的存放程度决定的

  * 这次存放，不放物品 i ，背包的价值为：`dp[i-1][j]`

  * 这次存放，放入物品 i ，**背包的价值为=上一次存放的背包物品 + 除去本次存放的种类（放入物品 i 之后的背包容量）+ 物品 i 的价值**

    `dp[i-1][j-weight[i]] + value[i]`

* 求的是背包的最大价值，所以递推公式应该是：存放物品 i 和不存放物品 i 背包价值的最大值

```
dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]+value[i]])
```

### 初始化dp数组

具体地来看，

```
      \  价值     15      30       40 
  物品  \ ——————————————————————————————  
   0    |         0       0        0
   1    |         15
   3    |         15
   4    |         15
```

由二维数组的特征来看，dp数组的元素值是由上一行和左上方的值推导而来，所以只需要初始化第一行和第一列的数组元素就可以了

* 第一行：物品0，说明没有物品，所以背包价值都为0
* 第一列：物品不管有多少，价值都只有15，所以背包的价值除了第一行之外，都为0
* 其余行列元素：初始为任意值都可以（为上一行和左上方推导而来，所以无所谓）

### 遍历顺序的确定

背包问题由两层for循环搞定背包和物品之间的遍历

* 先遍历背包，再遍历物品？

  体现在二维数组上就是**先行后列**，在for循环上就是：**外层循环遍历背包，内层循环遍历物品**。

  由于数组元素是由上一行和左上方的数值决定的，所以是可以的

* 先遍历物品，再遍历背包？

  体现在二维数组上就是**先行后列**，在for循环上就是：**外层循环遍历物品，内层循环遍历背包**

  理由同上

* 这里的“背包”是背包的容量

* **倒序遍历：**大可不必，理由同上

### 举例

这里可以通过完善上述表格来检验一下

## 代码实现

```C++
// 0-1背包问题母代码(二维)
void bags()
{
    vector<int> weight = {1, 3, 4};   //各个物品的重量
    vector<int> value = {15, 20, 30}; //对应的价值
    int bagWeight = 4;                //背包最大能放下多少重的物品

    // 二维数组：状态定义:dp[i][j]表示从0-i个物品中选择不超过j重量的物品的最大价值
    vector<vector<int>> dp(weight.size() + 1, vector<int>(bagWeight + 1, 0));	// 多出来初始化的行和列，所以 +1

    // 初始化:第一列都是0，第一行表示只选取0号物品最大价值
    for (int j = bagWeight; j >= weight[0]; j--)
        dp[0][j] = dp[0][j - weight[0]] + value[0];

    // weight数组的大小 就是物品个数
    for (int i = 1; i < weight.size(); i++) // 遍历物品(第0个物品已经初始化)
    {
        for (int j = 0; j <= bagWeight; j++) // 遍历背包容量
        {
            if (j < weight[i])           //背包容量已经不足以拿第i个物品了
                dp[i][j] = dp[i - 1][j]; //最大价值就是拿第i-1个物品的最大价值
            //背包容量足够拿第i个物品,可拿可不拿：拿了最大价值是前i-1个物品扣除第i个物品的 重量的最大价值加上i个物品的价值
            //不拿就是前i-1个物品的最大价值,两者进行比较取较大的
            else
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
        }
    }
    cout << dp[weight.size() - 1][bagWeight] << endl;
}

```

**优化：**

* dp数组优化：使用滚动的一维数组来进行替换。`dp[j]`：**表示的是背包容量为 j 时背包的最大价值**
* **递推公式：`dp[j]=max(dp[j],dp[j-weight[i]]+value[i])`**
* **遍历顺序：只能先遍历物品，再遍历背包容量**
  * **倒序遍历？**：**必须倒序遍历。**如果不倒序遍历的话，顺序遍历会使后序数组元素计算物品价值时重复计算多次（多次累加），因为dp数组中的元素是由它前一个元素决定的

*代码实现：*

```C++
void test_1_wei_bag_problem()
{
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    int bagWeight = 4;

    // 初始化
    vector<int> dp(bagWeight + 1, 0);
    for (int i = 0; i < weight.size(); i++)
    { // 遍历物品
        for (int j = bagWeight; j >= weight[i]; j--)
        {                                                     // 遍历背包容量(一定要逆序)
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); //不取或者取第i个
        }
    }
    cout << dp[bagWeight] << endl;
}

```

---

# 动态规划：最长公共子序列

## 动态规划四部曲

#### 确定dp数组

* `dp[i][j]`：表示在字符串1的前i个字符与字符串2的前j个字符的最长公共子序列

#### 确定递推公式

* 字符串1的第i个字符与字符串2的第j个字符相同：`dp[i][j]=dp[i-1][j-1]`，表示字符串前i-1个字符和字符串2前j-1个字符的最长公共子序列加一（加上当前情况）
* 字符串1的第i个字符与字符串2的第j个字符不相同：`dp[i][j]=max(dp[i-1][j],dp[i][j-1])`，表示字符串1的前i-1个字符与字符串2的前j个字符的最长公共子序列，和字符串的前i个字符与字符串2的前j-1个字符的最长公共子序列，取最大值（如果不相同，分别比较一个字符串的前一个位置与另一个字符串的当前位置）

#### 初始化

* `dp[0][j]`：当i=0时，表示字符串1为空，则字符串2不管是什么长度，都没有字符串与其匹配，所以`dp[0][j]=0`
* `dp[i][0]`：同上

#### 遍历顺序的确定

* 先遍历字符串1和先遍历字符串2是一样的：内外层for循环顺序
* 从小到大遍历即可，因为dp数组的每个位置的元素都是从上方、左方或者左上方求得的


```C++
class Solution{
public:
  int longestCommonSubsequence(string text1,string text2){
    int m=text1.size(); int n=text2.size();
    vector<vector<int>> dp(m+1,vector<int>(n+1));
    
    for(int i=1;i<=m;i++){
      char c1=text1[i-1];
      for(int j=1;j<=n;j++){
        char c2=text2[j-1];
        
        if(c1==c2){
          dp[i][j]=dp[i-1][j-1]+1;
        }else{
          dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
        }
      }
    }
    
    return dp[m][n];
  }  
};
```

---

# 动态规划：多边形三角形剖分的最低分数

*原题链接：https://leetcode-cn.com/problems/minimum-score-triangulation-of-polygon/submissions/*

```
给定 N，想象一个凸 N 边多边形，其顶点按顺时针顺序依次标记为 A[0], A[i], ..., A[N-1]。

假设您将多边形剖分为 N-2 个三角形。对于每个三角形，该三角形的值是顶点标记的乘积，三角剖分的分数是进行三角剖分后所有 N-2 个三角形的值之和。

返回多边形进行三角剖分后可以得到的最低分。
 

示例 1：

输入：[1,2,3]
输出：6
解释：多边形已经三角化，唯一三角形的分数为 6。
示例 2：



输入：[3,7,4,5]
输出：144
解释：有两种三角剖分，可能得分分别为：3*7*5 + 4*5*7 = 245，或 3*4*5 + 3*4*7 = 144。最低分数为 144。
示例 3：

输入：[1,3,1,4,1,5]
输出：13
解释：最低分数三角剖分的得分情况为 1*1*3 + 1*1*4 + 1*1*5 + 1*1*1 = 13。
 

提示：

3 <= A.length <= 50
1 <= A[i] <= 100

```



## 动态规划

有数组围成的多边形，假设其有N个顶点，先从中取出3个顶点（三个顶点组成三角形），之后再从剩下的顶点N-3个顶点中取出一个顶点组成四边形，划分三角形，之后再从剩下的顶点中取出一个顶点与之前的四边形组成五边形...... 一次类推

- 划分成三角形，可以直接计算出三角形值
- 划分成四边形，需要再次划分为两个三角形
- 划分成五边形，需要划分为一个四边形和一个三角形
- 。。。

### 确定dp数组

- `dp[i][j]`：表示在由数组组成的多边形中，区间【i，j】内剖分的三角形值的总和
- i：从N-3开始
- j：从2开始

### 确定递推公式

- `dp[i][j = value[i] * value[j] * value[m] + dp[i][m] + dp[m][j]]
- m：表示的是在区间【i，j】之间划分三角形`

### 初始化dp数组

由于是求分数的最低值，所以先将dp数组的各个元素初始化为0

- 如果`dp[i][j] = 0`，说明此时只是组成一个三角形，所以先初始化那些划分的单独的三角形为：
  `dp[i][j] = value[i] * value[j] * value[m] + dp[i][m] + dp[m][j]`
- 之后需要遍历每个区间，将其划分为三角形和多边形，进行递归

### 遍历顺序

首先需要两层for循环，确定 i，j 区间：外两层循环不需要顺序
再者，需要一层内循环用于划分三角形
**先确定区间，再划分三角形**

```C++
class Solution {
public:
    int minScoreTriangulation(vector<int>& values) {
        int n=values.size();

        int dp[n][n];   // 确定dp数组
        memset(dp,0,sizeof(dp));    // 初始化

        for(int i=n-3;i>=0;i--){    // 确定区间
            for(int j=2;j<n;j++){
                // 划分三角形
                for(int m=i+1;m<j;m++){
                    // 先初始化单独的三角形
                    if(dp[i][j]==0){
                        dp[i][j]=values[i]*values[j]*values[m]+dp[i][m]+dp[m][j];
                        // 划分多边形：多边形和三角形
                    }else{
                        dp[i][j]=min(dp[i][j],dp[i][m]+dp[m][j]+values[i]*values[j]*values[m]);
                    }
                }
            }
        }

        // 返回最大区间（整个多边形）的三角形值
        return dp[0][n-1];
    }
};
```

---

