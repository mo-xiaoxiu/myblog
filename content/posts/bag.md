---
title: "背包初始"
date: 2021-10-20T14:11:57+08:00
draft: true
---

# 背包

背包问题是**动态规划**的经典问题

## 0-1背包问题

| 物品 | 价值 |
| :--: | :--: |
|  0   |  0   |
|  1   |  15  |
|  3   |  30  |
|  4   |  40  |

**物品只能选择一次**，放入背包

## 动态规划五部曲

### 确定dp数组

这里可以使用dp二维数组来解决

* `dp[i][j]`：**物品 `0~i`放入背包时的重量`j`**，表示的是**背包的价值**

### 确定递推公式

* `dp[i][j]`是由什么决定的：上一次物品的存放程度决定的

  * 这次存放，不放物品 i ，背包的价值为：`dp[i-1][j]`

  * 这次存放，放入物品 i ，**背包的价值为=上一次存放的背包物品 + 除去本次存放的种类（放入物品 i 之后的背包容量）+ 物品 i 的价值**

    `dp[i-1][j-weight[i]] + value[i]`

* 求的是背包的最大价值，所以递推公式应该是：存放物品 i 和不存放物品 i 背包价值的最大值

```
dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]+value[i]])
```

### 初始化dp数组

具体地来看，

```
      \  价值     15      30       40 
  物品  \ ——————————————————————————————  
   0    |         0       0        0
   1    |         15
   3    |         15
   4    |         15
```

由二维数组的特征来看，dp数组的元素值是由上一行和左上方的值推导而来，所以只需要初始化第一行和第一列的数组元素就可以了

* 第一行：物品0，说明没有物品，所以背包价值都为0
* 第一列：物品不管有多少，价值都只有15，所以背包的价值除了第一行之外，都为0
* 其余行列元素：初始为任意值都可以（为上一行和左上方推导而来，所以无所谓）

### 遍历顺序的确定

背包问题由两层for循环搞定背包和物品之间的遍历

* 先遍历背包，再遍历物品？

  体现在二维数组上就是**先行后列**，在for循环上就是：**外层循环遍历背包，内层循环遍历物品**。

  由于数组元素是由上一行和左上方的数值决定的，所以是可以的

* 先遍历物品，再遍历背包？

  体现在二维数组上就是**先行后列**，在for循环上就是：**外层循环遍历物品，内层循环遍历背包**

  理由同上

* 这里的“背包”是背包的容量

* **倒序遍历：**大可不必，理由同上

### 举例

这里可以通过完善上述表格来检验一下

## 代码实现

```C++
// 0-1背包问题母代码(二维)
void bags()
{
    vector<int> weight = {1, 3, 4};   //各个物品的重量
    vector<int> value = {15, 20, 30}; //对应的价值
    int bagWeight = 4;                //背包最大能放下多少重的物品

    // 二维数组：状态定义:dp[i][j]表示从0-i个物品中选择不超过j重量的物品的最大价值
    vector<vector<int>> dp(weight.size() + 1, vector<int>(bagWeight + 1, 0));	// 多出来初始化的行和列，所以 +1

    // 初始化:第一列都是0，第一行表示只选取0号物品最大价值
    for (int j = bagWeight; j >= weight[0]; j--)
        dp[0][j] = dp[0][j - weight[0]] + value[0];

    // weight数组的大小 就是物品个数
    for (int i = 1; i < weight.size(); i++) // 遍历物品(第0个物品已经初始化)
    {
        for (int j = 0; j <= bagWeight; j++) // 遍历背包容量
        {
            if (j < weight[i])           //背包容量已经不足以拿第i个物品了
                dp[i][j] = dp[i - 1][j]; //最大价值就是拿第i-1个物品的最大价值
            //背包容量足够拿第i个物品,可拿可不拿：拿了最大价值是前i-1个物品扣除第i个物品的 重量的最大价值加上i个物品的价值
            //不拿就是前i-1个物品的最大价值,两者进行比较取较大的
            else
                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
        }
    }
    cout << dp[weight.size() - 1][bagWeight] << endl;
}

```

**优化：**

* dp数组优化：使用滚动的一维数组来进行替换。`dp[j]`：**表示的是背包容量为 j 时背包的最大价值**
* **递推公式：`dp[j]=max(dp[j],dp[j-weight[i]]+value[i])`**
* **遍历顺序：只能先遍历物品，再遍历背包容量**
  * **倒序遍历？**：**必须倒序遍历。**如果不倒序遍历的话，顺序遍历会使后序数组元素计算物品价值时重复计算多次（多次累加），因为dp数组中的元素是由它前一个元素决定的

*代码实现：*

```C++
void test_1_wei_bag_problem()
{
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    int bagWeight = 4;

    // 初始化
    vector<int> dp(bagWeight + 1, 0);
    for (int i = 0; i < weight.size(); i++)
    { // 遍历物品
        for (int j = bagWeight; j >= weight[i]; j--)
        {                                                     // 遍历背包容量(一定要逆序)
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]); //不取或者取第i个
        }
    }
    cout << dp[bagWeight] << endl;
}

```

---

