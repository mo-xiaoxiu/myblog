---
title: "Cookie、Session、Token为何物？"
date: 2021-09-08T09:09:17+08:00
draft: true
---
# Cookie、Session、Token
## 网站交互式体验
### 无状态的http协议
* 概念：是指**协议对于业务处理没有记忆**，每次请求都是独立的，没有上下文信息
* 缺点：后续处理需要前面的信息，重传关键信息会导致数据量增大
* 解决：
    1.*客户端买单*：客户端每次请求把自己必要的信息封装发送给服务器，服务器查收处理
    2.*服务器买单*：客户端第一次请求之后，服务器记录，客户端后续请求只需发送最基本的少量信息
### Cookie方案
* 保存在客户端
* 分类：*内存Cookie* 和 *硬盘Cookie*
* 内存Cookie：非持久化存储
* 硬盘Cookie：持久化存储
#### Cookie定义与作用
* 定义：**HTTP Cookie(Web Cookie)**：服务器发送到用户浏览器，保存在本地的一小块数据。它会在浏览器下一次向同一服务器发送请求时被携带到服务器上
* 作用
  	* 会话状态管理：*用户登陆状态*
  	* 个性化设置：*主题设置*
  	* 浏览器行为跟踪：*跟踪分析用户行为*

#### 服务端创建Cookie

服务器收到HTTP请求之后，可以在响应头里添加`Set_Cookie`选项

**浏览器**收到响应后通常会保存Cookie，之后对该服务器的每一次请求都通过**Cookie请求头部**将Cookie信息发送给服务器。包括*Cookie的常见属性：域、路径、有效时间、使用限制等*

#### B/S的Cookie交互

服务器使用**Set-Cookie 响应头部**向用户浏览器发送 Cookie信息

客户端对该服务器发起的每一次新请求，浏览器都会将之前保存的Cookie信息通过 Cookie 请求头部再发送给服务器

#### 存在问题

* 客户端对该服务器发起的每一次新请求，浏览器都会将之前保存的Cookie信息通过 Cookie 请求头部再发送给服务器
* 跨站请求伪造CSRF。*比如你在登录银行网站的同时，登录了一个钓鱼网站，在钓鱼网站进行某些操作时可能会获取银行网站相关的Cookie信息，向银行网站发起转账等非法行为。*
* *解决：*用户的任何敏感操作都需要确认，并且敏感信息的 Cookie 只能拥有较短的生命周期
* **特别注意：以上存在的问题只是Cookie被用于实现交互状态时存在的问题，但并不是说Cookie本身的问题**

### Session方案

* Cookie：客户端行为；Session：服务端行为
* **Cookie机制**在最初和服务端完成交互后，保持状态所需的信息都将存储在**客户端**，后续直接读取发送给服务端进行交互
* **Session机制**将用户的所有活动信息、上下文信息、登录信息等都存储在**服务端**，只是**生成一个唯一标识ID发送给客户端**，后续的交互将没有重复的用户信息传输，取而代之的是唯一标识ID，暂且称之为Session-ID吧

#### 简单的交互流程

* 客户端*第一次请求session对象*时，*服务器*会为客户端*创建一个session*，通过*特殊算法*算出一个session的ID，*标识该session对象*
* 浏览器*下次请求*别的资源的时候，会将*sessionID放置到请求头*中，服务器接收到请求后*解析得到sessionID*，服务器找到该id的session来确定请求方的身份和一些上下文信息

#### Session的实现方式

* *“Session和Cookie的关系就像加班和加班费的关系，看似关系很密切，实际上没啥关系”*

* | Session机制 | 方式        |
  | ----------- | ----------- |
  | 默认首选    | Cookie载体  |
  | Cookie禁用  | URLchongxie |

  将会话标识号以参数形式附加在超链接的URL地址后面的技术称为**URL重写**

#### 存在问题

* **海量用户时巨大的存储压力**

* **分布式系统中信息的共享问题**：对于大型网站必然是集群化&分布式的服务器配置，如果Session信息是存储在本地的，那么由于负载均衡的作用，原来请求机器A并且存储了Session信息，下一次请求可能到了机器B，此时机器B上并没有Session信息。

  这种情况下要么在B机器重复创建造成浪费，要么引入高可用的Session集群方案，引入Session代理实现信息共享，要么实现定制化哈希到集群A，这样做其实就有些复杂了

### Token方案

* 身份令牌，由服务端生成发放给客户端，一种时效性的身份验证方式

#### 简单的交互流程

* 客户端将用户的信息发送给服务端
* 服务端收到信息后校验并生成一个token值返回给客户端
* 客户端收到token值后保存在本地，后续请求该服务器时都携带这个token进行身份校验
* 服务器在收到客户端的请求时，通过解析token值，获取关键信息，根据相同的加密算法、密钥、用户参数生成sign与客户端的sign进行对比，一致则通过，否则拒绝服务
* 验证通过后，服务端根据token中的uid获取用户信息，请求业务响应

#### Token的设计思想

* **header头部信息**：加密算法信息
* **payload净荷信息**：用户信息、过期时间
* **Signature签名信息**：验证服务端的重要凭证。由header头部信息、payload净荷信息和密钥key生成

### Token方案特点

* Token可以**跨站共享**，实现**单点登录**
* Token机制**无需太多存储空间**，Token包含了用户的信息，**只需在客户端存储状态信息即可**，对于服务端的扩展性很好
* Token机制的安全性依赖于服务端**加密算法和密钥的安全性**
* Token机制也**不是万金油**



*参考文章：https://mp.weixin.qq.com/s/ZAT9ImeyQwnS4i67PwIlLg*

