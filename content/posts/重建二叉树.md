---
title: "重建二叉树"
date: 2021-09-14T15:04:30+08:00
draft: true
---

# 重建二叉树

* *问题：给定一个二叉树的先序遍历和中序遍历的数组，根据这两个数组将原来的二叉树重建出来*

---

## 题解

* 首先明确：
  * 二叉树的先序遍历数组，根节点在第一个元素位置
  * 二叉树的中序遍历数组，根节点之前的元素都是二叉树的左子树，根节点的右边的所有的元素都是右子树
* 利用递归解决
  * 根据中序遍历数组的根节点索引将数组划分为子数组，分别进行寻找根节点和左右子树，直到左右边界越界，即二叉树到达叶节点

```C++
/*
struct TreeNode{
	int val;
	TreeNode* left;
	TreeNode* right;
	
	// constructor
	TreeNode():val(0),left(nullptr),right(nullptr){}
	TreeNode(int x):val(x),left(nullptr),right(nullptr){}
};
*/

class Sulotion{
    private:
    // 创建一个哈希表，用来记录中序遍历数组的key（索引）和value（元素值）
    	unordered_map<int,int>index;
    
    public:
    	TreeNode* mybuildTree(vector<int>& preorder,vector<int>& inorder,int pre_left,int pre_right,int in_left,int in_right){
            int pre_root=pre_left;	// 	先序遍历数组的第一个元素就是第一次递归的根节点
            int in_root=index[pre_root];	// 根据先序遍历的根节点找到中序遍历中根节点的索引
            
            TreeNode* root=new TreeNode(preorder[pre_root]);	// 创建根节点
            
            int size_leftTree=in_root-in_left;	// 得出左子树节点数量
            
            root->left=mybuildTree(preorder,inorder,pre_left+1,pre_left+size,in_left,in_root-1);
            // 递归重建左子树
            // 边界条件：
            // 1. 左子树左边界：对于先序遍历数组，由于第一个元素是根节点，左子树在根节点之后开始，所以是pre_left+1;对于中序遍历数组，根节点之前是左子树，所以左边界就是原来的in_left
            // 2. 左子树右边界：对于先序遍历数组，左子树右边界就是左边界加上左子树节点数量；对于中序遍历数组，根节点之前一个位置就是左子树有边界
            root->right=mybuildTree(preorder,inorder,pre_left+size+1,in_root+1,in_right);
            // 对于右子树同理分析
            
            return root;
        }
    
    
    	TreeNode* buildTree(vector<int>& preorder,vector<int>& inorder){
            if(preorder.size()==0 || inordeer.size()==0) return nullptr;
            
            int n=preorder.size();
            for(int i=0;i<n;i++){
                // 将中序遍历数组的索引和元素值放入哈希表，方便查找根节点的索引，从而可以得出左子树和右子树的边界位置
                index[inorder[i]]=i;
            }
            
            return mybuildTree(preorder,inorder,0,n-1,0,n-1);
        }
};
```

