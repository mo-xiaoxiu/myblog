---
title: "数组知识点之滑动窗口"
date: 2021-09-29T12:58:43+08:00
draft: true
---

# 滑动窗口

滑动窗口和双指针有点像，是双指针的一种用法

---

## 长度最小的子数组

```
给定一个含有 n 个正整数的数组和一个正整数 target 。

找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。

 

示例 1：

输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
示例 2：

输入：target = 4, nums = [1,4,4]
输出：1
示例 3：

输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0


提示：

1 <= target <= 109
1 <= nums.length <= 105
1 <= nums[i] <= 105
```

*原题链接：https://leetcode-cn.com/problems/minimum-size-subarray-sum/*

*代码实现：*

```C++
class Solution {
public:
    int minSubArrayLen(int target, vector<int>& nums) {
        int res=INT32_MAX;	// 记录最终结果
        int sublength=0;	// 记录子数组长度
        int i=0;	// 窗口左端位置
        int sum=0;
        for(int j=0;j<nums.size();j++){
            sum+=nums[j];
            while(sum>=target){
                sublength=j-i+1;
                res=min(res,sublength);
                sum-=nums[i++];	// 不断右移左端窗口位置，缩小窗口
            }
        }
        return res==INT32_MAX?0:res;
    }
};
```

---

## 水果成篮

```
在一排树中，第 i 棵树产生 tree[i] 型的水果。
你可以从你选择的任何树开始，然后重复执行以下步骤：

把这棵树上的水果放进你的篮子里。如果你做不到，就停下来。
移动到当前树右侧的下一棵树。如果右边没有树，就停下来。
请注意，在选择一颗树后，你没有任何选择：你必须执行步骤 1，然后执行步骤 2，然后返回步骤 1，然后执行步骤 2，依此类推，直至停止。

你有两个篮子，每个篮子可以携带任何数量的水果，但你希望每个篮子只携带一种类型的水果。

用这个程序你能收集的水果树的最大总量是多少？

 

示例 1：

输入：[1,2,1]
输出：3
解释：我们可以收集 [1,2,1]。
示例 2：

输入：[0,1,2,2]
输出：3
解释：我们可以收集 [1,2,2]
如果我们从第一棵树开始，我们将只能收集到 [0, 1]。
示例 3：

输入：[1,2,3,2,2]
输出：4
解释：我们可以收集 [2,3,2,2]
如果我们从第一棵树开始，我们将只能收集到 [1, 2]。
示例 4：

输入：[3,3,3,1,2,1,1,2,3,3,4]
输出：5
解释：我们可以收集 [1,2,1,1,2]
如果我们从第一棵树或第八棵树开始，我们将只能收集到 4 棵水果树。
 

提示：

1 <= tree.length <= 40000
0 <= tree[i] < tree.length

```

*原题链接：https://leetcode-cn.com/problems/fruit-into-baskets/*

*代码实现：*

```C++
class Solution {
public:
    int totalFruit(vector<int>& fruits) {
        int res=0;
        unordered_map<int,int>map;	// 用一个哈希表记录“水果种类数”：数组中出现的元素及其个数
        int left=0;
        for(int i=0;i<fruits.size();i++){
            map[fruits[i]]++;
            // 判断是否超过两种“水果”
            // 如果超过：右移左端位置，缩小窗口
            while(map.size()>2){
                int cur=fruits[left];
                --map[cur];
                if(map[cur]==0){
                    map.erase(fruits[left]);
                }
                left++;
            }
            res=max(res,i-left+1);
        }
        return res;
    }
};
```

---

## 最小覆盖子串

```
给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 "" 。

 

注意：

对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。
如果 s 中存在这样的子串，我们保证它是唯一的答案。
 

示例 1：

输入：s = "ADOBECODEBANC", t = "ABC"
输出："BANC"
示例 2：

输入：s = "a", t = "a"
输出："a"
示例 3:

输入: s = "a", t = "aa"
输出: ""
解释: t 中两个字符 'a' 均应包含在 s 的子串中，
因此没有符合条件的子字符串，返回空字符串。
 

提示：

1 <= s.length, t.length <= 105
s 和 t 由英文字母组成


```

*代码实现：*

```C++
class Solution {
public:
    string minWindow(string s, string t) {
        unordered_map<char,int>hs,ht;	// 分别用两个哈希表记录字符串出现的次数
        string res;

        // 先将原始字符串放入第一个哈希表，方便对比t字符串
        for(int i=0;i<t.size();i++){
            ht[t[i]]++;
        }

        // count： 记录原始字符串中新元素出现的个数（计数器）
        int count=0;
        // 两个指针维护窗口：j 用来遍历
        for(int i=0,j=0;j<s.size();j++){
            // 另一个哈希表记录待查字符串的元素出现次数
            hs[s[j]]++;
            // 如果查到的字符串对于待查字符串来说出现过且数目还没查够，计数器+1
            if(hs[s[j]]<=ht[s[j]]){
                count++;
            }

            // 当窗口左端元素出现次数大于待查字符串出现的次数，缩小窗口
            while(hs[s[i]]>ht[s[i]]){
                hs[s[i++]]--;
            }

            // count==t.size() 说明待查字符串的所有字符都已经查完了，且都出现了（包含重复次数）
            if(count==t.size()){
                if(res.empty() || j-i+1<res.size()){
                    res=s.substr(i,j-i+1);
                }
            }
        }
        return res;
    }
};
```

---

**总结：**

* 滑动窗口就是维护两个指针分别指向窗口的左端和右端
* 右指针不断向右遍历拓展窗口，满足要求的元素则进入窗口
* 当窗口中某些条件不满足时，可以通过右移左指针（缩小窗口）使条件重新满足

