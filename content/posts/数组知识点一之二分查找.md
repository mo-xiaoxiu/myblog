---
title: "数组知识点一之二分查找"
date: 2021-09-20T16:35:06+08:00
draft: true
---

# 数组：二分查找

学了一些算法知识，是时候做一些阶段性总结了：

---

首先是二分查找。**利用二分查找的题目的特点：**

***数组有序，无重复数字***

## 二分查找

首先是二分查找的模板：

```C++
// 二分查找

class Solution{
    public:
    	int findTarget(vector<int>& nums){
            int left=0;							// 定义查找的左边界
            int right=nums.size()-1;			 // 定义查找的右边界
            while(left<=right){					 // 区间：左闭右闭
                if(nums[mid]<target){			 // 数组中间位置数值比目标值小，说明目标值在中间位置的右边
                    left=mid+1;					// 增大左区间，继续遍历
                }else if(nums[mid]>target){		 // 数组中间位置数值比目标值大，说明目标值在中间位置的左边
                    right=mid-1;				// 缩小右区间
                }else{
                    return mid;					// 找到目标值，返回该值
                }
            }
            return -1;							// 未找到目标值，返回-1
        }
};
```

有关二分查找的题目如下：

### 搜索插入位置

*原题链接：https://leetcode-cn.com/problems/search-insert-position/*

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 O(log n) 的算法。

 

示例 1:

输入: nums = [1,3,5,6], target = 5
输出: 2
示例 2:

输入: nums = [1,3,5,6], target = 2
输出: 1
示例 3:

输入: nums = [1,3,5,6], target = 7
输出: 4
示例 4:

输入: nums = [1,3,5,6], target = 0
输出: 0
示例 5:

输入: nums = [1], target = 0
输出: 0


提示:

1 <= nums.length <= 104
-104 <= nums[i] <= 104
nums 为无重复元素的升序排列数组
-104 <= target <= 104



*代码：*

```C++
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
		int left=0;
        int right=nums.size()-1;
        while(left<=right){
            int mid=left+(right-left)/2;
            if(nums[mid]<target){
             	left=mid+1;   
            }else if(nums[mid]>target){
                right=mid-1;
            }else{
                return mid;
            }
        }
        /*
        分几种情况：
        1.target小于数组中最小值,即target在数组的左边
        2.target在数组范围内且等于某个数
        3.target在数组范围内，但不等于某个数，将它插在某个数之后
        4.target大于数组中的最大值，即target在数组的右边
        */
        return right+1;
    }
};
```

### 在排序数组中找到元素第一个位置和最后一个位置

*原题链接：https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/*

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。

进阶：

你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？


示例 1：

输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
示例 2：

输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]
示例 3：

输入：nums = [], target = 0
输出：[-1,-1]


提示：

0 <= nums.length <= 105
-109 <= nums[i] <= 109
nums 是一个非递减数组
-109 <= target <= 109



*代码：*

```C++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int leftBorder = getLeftBorder(nums, target);
        int rightBorder = getRightBorder(nums, target);
        // 情况一
        if (leftBorder == -2 || rightBorder == -2) return {-1, -1};
        // 情况三
        if (rightBorder - leftBorder > 1) return {leftBorder + 1, rightBorder - 1};
        // 情况二
        return {-1, -1};
    }
private:
     int getRightBorder(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        int rightBorder = -2; // 记录一下rightBorder没有被赋值的情况
        while (left <= right) {
            int middle = left + ((right - left) / 2);
            if (nums[middle] > target) {
                right = middle - 1;
            } else { // 寻找右边界，nums[middle] == target的时候更新left
                left = middle + 1;
                rightBorder = left;
            }
        }
        return rightBorder;
    }
    int getLeftBorder(vector<int>& nums, int target) {
        int left = 0;
        int right = nums.size() - 1;
        int leftBorder = -2; // 记录一下leftBorder没有被赋值的情况
        while (left <= right) {
            int middle = left + ((right - left) / 2);
            if (nums[middle] >= target) { // 寻找左边界，nums[middle] == target的时候更新right
                right = middle - 1;
                leftBorder = right;
            } else {
                left = middle + 1;
            }
        }
        return leftBorder;
    }
};
```

### x的平方根

*原题链接：https://leetcode-cn.com/problems/sqrtx/*

给你一个非负整数 x ，计算并返回 x 的 平方根 。

由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。

注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。

 

示例 1：

输入：x = 4
输出：2
示例 2：

输入：x = 8
输出：2
解释：8 的平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。


提示：

0 <= x <= 231 - 1

*代码：*

```C++
class Solution {
public:
    int mySqrt(int x) {
        long left=0;
        long right=x;
        while(left<=right){
            long mid=left+(right-left)/2;
            if(mid*mid<x){				// mid平方小于x，x的平方根在mid的右边
                left=mid+1;
            }else if(mid*mid>x){		// mid平方大于x，x的平方根在mid的左边
                right=mid-1;
            }else{
                return mid;				// 找到完全平方根
            }
        }
        return right;					// 根据题目舍掉小数部分，而我们数组的右区间都是从中间位置左边一个数开始，所以返回右区间
    }
};
```

### 有效的完全平方数

*原题链接：https://leetcode-cn.com/problems/valid-perfect-square/*

给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。

进阶：不要 使用任何内置的库函数，如  sqrt 。

 

示例 1：

输入：num = 16
输出：true
示例 2：

输入：num = 14
输出：false


提示：

1 <= num <= 2^31 - 1



*代码：*

```C++
class Solution {
public:
    bool isPerfectSquare(int num) {
        long left=0;
        long right=num;
        while(left<=right){
            long mid=left+(right-left)/2;
            if(mid*mid<num){
                left=mid+1;
            }else if(mid*mid>num){
                right=mid-1;
            }else{
                return true;		// 找到完全平方数，返回真
            }
        }
        return false;				// 找不到完全平方数，返回假
    }
};
```

### 在排序数组中查找数

*原题链接：https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/*

统计一个数字在排序数组中出现的次数。

 

示例 1:

输入: nums = [5,7,7,8,8,10], target = 8
输出: 2
示例 2:

输入: nums = [5,7,7,8,8,10], target = 6
输出: 0


提示：

0 <= nums.length <= 105
-109 <= nums[i] <= 109
nums 是一个非递减数组
-109 <= target <= 109



*代码：*

```C++
class Solution {
public:
    int findBorder(vector<int>& nums,int target){
        int left=0;
        int right=nums.size()-1;
        while(left<=right){
            int mid=left+(right-left)/2;
            if(nums[mid]<=target){			// 将相等(找到)的情况计入左区间变化的情况
                left=mid+1;
            }else{
                right=mid-1;
            }
        }
        return left;
    }

    int search(vector<int>& nums, int target) {
        return findBorder(nums,target)-findBorder(nums,target-1);   // 用前一个数的左索引值减去后一个数的左索引值
    }
};
```

